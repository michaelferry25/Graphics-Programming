<!DOCTYPE html>
<html>

  <head>
    <meta charset="UTF-8">
    <title>Bouncing Polygon Game</title>

    <style type="text/css">
      canvas {
        border: 1px solid grey; 
      }
    </style>

  </head>

  <body>
    <canvas id="gameCanvas" width="500" height="400"></canvas>

    <script type="text/javascript">
      // Set up canvas
      var canvas = document.getElementById("gameCanvas");
      var ctx = canvas.getContext("2d");

      // Complex polygon object (instead of the ball)
      var complexPolygon = {
        x: 250,
        y: 200,
        dx: 2,
        dy: 2,
        gravity: 0.1, // Downward acceleration
        bounceFactor: 0.99, // Kinetic energy loss factor
        angle: 0, // Initial rotation angle
        rotationSpeed: 0.015, // Initial rotation speed
        draw: function() {
          ctx.save(); // Save the current state of the canvas

          // Move to the center of the polygon
          ctx.translate(this.x, this.y);
          // Rotate the polygon
          ctx.rotate(this.angle);

          // Draw the complex polygon (star shape with square inside)
          ctx.beginPath();
          ctx.moveTo(0, -30); // Top point
          ctx.lineTo(20, -10); // Right top
          ctx.lineTo(40, -30); // Right bottom point
          ctx.lineTo(10, 0); // Bottom right
          ctx.lineTo(40, 30); // Bottom right
          ctx.lineTo(20, 10); // Right bottom
          ctx.lineTo(0, 30); // Bottom point
          ctx.lineTo(-20, 10); // Left bottom
          ctx.lineTo(-40, 30); // Bottom left
          ctx.lineTo(-10, 0); // Bottom left
          ctx.lineTo(-40, -30); // Left bottom point
          ctx.lineTo(-20, -10); // Left top
          ctx.closePath();

          ctx.fillStyle = "blue";
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "black";
          ctx.stroke();

          // Draw the center square
          ctx.beginPath();
          ctx.rect(-10, -10, 20, 20);
          ctx.fillStyle = "black";
          ctx.fill();
          ctx.stroke();

          ctx.restore(); // Restore the canvas state
        },
        move: function() {
          // Apply gravity
          this.dy += this.gravity;

          // Update the position of the polygon
          this.x += this.dx;
          this.y += this.dy;

          // Bounce off top and bottom walls
          if (this.y + 30 > canvas.height) { // Bottom wall
            this.y = canvas.height - 30; // Reset position to avoid sticking
            this.dy = -this.dy * this.bounceFactor; // Bounce up with reduced energy
            this.updateRotationSpeed(); // Update speed on contact
          }

          if (this.y - 30 < 0) { // Top wall
            this.y = 30; // Prevent object from moving above the canvas
            this.dy = -this.dy; // Reverse the direction without energy loss at the top
          }

          // Check if the polygon goes off the left or right side of the canvas
          if (this.x + 30 > canvas.width || this.x - 30 < 0) {
            this.reset(); // Reset the polygon if it goes off the sides
          }

          // Apply the rotation speed
          this.angle += this.rotationSpeed;
        },
        updateRotationSpeed: function() {
          // Change rotation speed based on the speed of movement (simple example)
          var speedFactor = Math.abs(this.dx) + Math.abs(this.dy);
          this.rotationSpeed = 0.01 + (speedFactor * 0.005); // Adjust the formula as needed
        },
        reset: function() {
          this.x = 250;
          this.y = 200;
          this.dx = 2;
          this.dy = 2;
          this.angle = 0;
          this.rotationSpeed = 0.01;
        }
      };

      // Paddle class
      class Paddle {
        constructor(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.dy = 8; // Increased paddle speed
        }

        // Draw the paddle
        draw() {
          ctx.beginPath();
          ctx.rect(this.x, this.y, this.width, this.height);
          ctx.fillStyle = "black";
          ctx.fill();
          ctx.closePath();
        }

        // Move the paddle based on keyboard input (up/down arrows or W/S keys)
        move(direction) {
          if (direction === "up" && this.y > 0) {
            this.y -= this.dy;
          } else if (direction === "down" && this.y + this.height < canvas.height) {
            this.y += this.dy;
          }
        }

        // Move the paddle to the mouse's y-coordinate
        moveTo(yPosition) {
          if (yPosition >= 0 && yPosition + this.height <= canvas.height) {
            this.y = yPosition;
          }
        }
      }

      // Instantiate two paddles
      var leftPaddle = new Paddle(10, 150, 10, 100); // Left paddle
      var rightPaddle = new Paddle(480, 150, 10, 100); // Right paddle

      // Detect collision between the polygon and paddles
      function detectCollision(paddle) {
        return (
          complexPolygon.x - 30 < paddle.x + paddle.width && // Check if polygon is within paddle's x-range
          complexPolygon.x + 30 > paddle.x && // Check if polygon overlaps paddle horizontally
          complexPolygon.y > paddle.y && // Check if polygon is within paddle's y-range
          complexPolygon.y < paddle.y + paddle.height
        );
      }

      // Keydown event listener to control the paddles
      document.addEventListener("keydown", function(event) {
        // Left paddle (W/S keys)
        if (event.key === "w" || event.key === "W") {
          leftPaddle.move("up");
        } else if (event.key === "s" || event.key === "S") {
          leftPaddle.move("down");
        }

        // Right paddle (Arrow keys)
        if (event.key === "ArrowUp") {
          rightPaddle.move("up");
        } else if (event.key === "ArrowDown") {
          rightPaddle.move("down");
        }
      });

      // Game loop
      function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

        complexPolygon.draw();
        complexPolygon.move();

        // Check for paddle collisions and reverse direction on hit
        if (detectCollision(leftPaddle)) {
          complexPolygon.dx = Math.abs(complexPolygon.dx); // Ensure the polygon moves to the right after hitting the left paddle
          complexPolygon.updateRotationSpeed(); // Update rotation speed based on collision
        }

        if (detectCollision(rightPaddle)) {
          complexPolygon.dx = -Math.abs(complexPolygon.dx); // Ensure the polygon moves to the left after hitting the right paddle
          complexPolygon.updateRotationSpeed(); // Update rotation speed based on collision
        }

        leftPaddle.draw(); // Draw the left paddle
        rightPaddle.draw(); // Draw the right paddle

        requestAnimationFrame(gameLoop); // Continue the game loop
      }

      // Start the game loop
      gameLoop();
    </script>
  </body>

</html>

